{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red173\green169\blue32;\red32\green32\blue32;\red88\green118\blue71;
\red109\green109\blue109;\red153\green168\blue186;\red86\green132\blue173;\red191\green100\blue38;\red254\green187\blue91;
\red166\green165\blue220;}
{\*\expandedcolortbl;;\csgenericrgb\c67843\c66275\c12549;\csgenericrgb\c12549\c12549\c12549;\csgenericrgb\c34510\c46275\c27843;
\csgenericrgb\c42745\c42745\c42745;\csgenericrgb\c60000\c65882\c72941;\csgenericrgb\c33725\c51765\c67843;\csgenericrgb\c74902\c39216\c14902;\csgenericrgb\c99608\c73333\c35686;
\csgenericrgb\c65098\c64706\c86275;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \cb3 #include \cf4 <stdio.h>\
\cf2 #include \cf4 <stdlib.h>\
\cf2 #include \cf4 <unistd.h>\
\cf2 #include \cf4 <sys/wait.h>\
\cf2 #include \cf4 <sys/time.h>  \cf5 // Include the header for gettimeofday\
\
\cf2 #define \cf6 ARRAY_SIZE \cf7 100\
\cf2 #define \cf6 NUM_CHILDREN \cf7 8\
\
\cf8 int \cf9 main\cf6 () \{\
    \cf8 struct \cf10 timeval \cf6 start_t\cf8 , \cf6 end_t\cf8 ;  \cf5 // Use struct timeval for time measurements\
    \cf8 int \cf6 idMatrix[\cf7 100\cf6 ][\cf7 100\cf6 ]\cf8 ;\
    int \cf6 idxBirthYearMatrix[\cf7 100\cf6 ][\cf7 100\cf6 ]\cf8 ;\
    int \cf6 multiplicationMatrix[\cf7 100\cf6 ][\cf7 100\cf6 ]\cf8 ;\
    int \cf6 id = \cf7 1210249\cf8 ;\
    int \cf6 ID[\cf7 10\cf6 ]\cf8 ; \cf5 // 1D array to contain id numbers\
    \cf8 int \cf6 size1 = \cf7 0\cf8 ; \cf5 // size of 1D id array\
\
    // fill the id numbers into 1D array\
    \cf8 while \cf6 (id > \cf7 0\cf6 ) \{\
        ID[size1] = id % \cf7 10\cf8 ;\
        \cf6 size1++\cf8 ;\
        \cf6 id /= \cf7 10\cf8 ;\
    \cf6 \}\
\
    \cf5 // reverse the array because it was filled reversed\
    \cf8 for \cf6 (\cf8 int \cf6 i = \cf7 0\cf8 ; \cf6 i < size1 / \cf7 2\cf8 ; \cf6 i++) \{\
        \cf8 int \cf6 temp = ID[i]\cf8 ;\
        \cf6 ID[i] = ID[size1 - \cf7 1 \cf6 - i]\cf8 ;\
        \cf6 ID[size1 - \cf7 1 \cf6 - i] = temp\cf8 ;\
    \cf6 \}\
\
    \cf8 long long \cf6 idMulBirth = \cf7 1210249l \cf6 * \cf7 2003l\cf8 ;\
    int \cf6 idXbirthYear[\cf7 20\cf6 ]\cf8 ; \cf5 // 1D array to contain (id * birth year) numbers\
    \cf8 int \cf6 size2 = \cf7 0\cf8 ; \cf5 // size of 1D id * BirthYear array\
\
    // fill the id multiplied with the birth year into 1D array\
    \cf8 while \cf6 (idMulBirth > \cf7 0\cf6 ) \{\
        idXbirthYear[size2] = idMulBirth % \cf7 10\cf8 ;\
        \cf6 idMulBirth /= \cf7 10\cf8 ;\
        \cf6 size2++\cf8 ;\
    \cf6 \}\
\
    \cf5 // reverse the array because it was filled reversed\
    \cf8 for \cf6 (\cf8 int \cf6 i = \cf7 0\cf8 ; \cf6 i < size2 / \cf7 2\cf8 ; \cf6 i++) \{\
        \cf8 int \cf6 temp = idXbirthYear[i]\cf8 ;\
        \cf6 idXbirthYear[i] = idXbirthYear[size2 - \cf7 1 \cf6 - i]\cf8 ;\
        \cf6 idXbirthYear[size2 - \cf7 1 \cf6 - i] = temp\cf8 ;\
    \cf6 \}\
\
    \cf5 // fill the id matrix and id * birth year matrix\
    \cf8 int \cf6 k = \cf7 0\cf8 , \cf6 l = \cf7 0\cf8 ;\
    for \cf6 (\cf8 int \cf6 i = \cf7 0\cf8 ; \cf6 i < \cf7 100\cf8 ; \cf6 i++) \{\
        \cf8 for \cf6 (\cf8 int \cf6 j = \cf7 0\cf8 ; \cf6 j < \cf7 100\cf8 ; \cf6 j++) \{\
            \cf8 if \cf6 (k == size1)\
                k = \cf7 0\cf8 ;\
            if \cf6 (l == size2)\
                l = \cf7 0\cf8 ;\
            \cf6 idMatrix[i][j] = ID[k]\cf8 ;\
            \cf6 idxBirthYearMatrix[i][j] = idXbirthYear[l]\cf8 ;\
            \cf6 l++\cf8 ;\
            \cf6 k++\cf8 ;\
        \cf6 \}\
    \}\
    \cf8 int \cf6 rows_per_child = ARRAY_SIZE / NUM_CHILDREN + \cf7 1\cf8 ; \cf5 // Rows assigned to each child(I added 1 to avoid missing any row when the number of children is negative)\
    \cf8 int \cf6 pipe_fds[NUM_CHILDREN][\cf7 2\cf6 ]\cf8 ; \cf5 //create a pipe for each child\
    \cf6 gettimeofday(&start_t\cf8 , \cf6 NULL)\cf8 ;  \cf5 // Get the start time\
\
    \cf8 for \cf6 (\cf8 int \cf6 i = \cf7 0\cf8 ; \cf6 i < NUM_CHILDREN\cf8 ; \cf6 i++) \{\
        \cf8 if \cf6 (pipe(pipe_fds[i]) == -\cf7 1\cf6 ) \{\
            perror(\cf4 "Pipe creation failed"\cf6 )\cf8 ;\
            return \cf7 1\cf8 ;\
        \cf6 \}\
    \}\
\
    pid_t pids[NUM_CHILDREN]\cf8 ; \cf5 // create pid for each child\
\
    \cf8 for \cf6 (\cf8 int \cf6 i = \cf7 0\cf8 ; \cf6 i < NUM_CHILDREN\cf8 ; \cf6 i++) \{\
        pids[i] = fork()\cf8 ; \cf5 // creating a child\
        \cf8 if \cf6 (pids[i] < \cf7 0\cf6 ) \{\
            printf(\cf4 "Fork failed"\cf6 )\cf8 ;\
        \cf6 \}\
        \cf8 else if \cf6 (pids[i] == \cf7 0\cf6 ) \{\
            \cf5 // Child process\
            \cf6 close(pipe_fds[i][\cf7 0\cf6 ])\cf8 ;\
\
            \cf5 // To store the child result\
            \cf8 int \cf6 ans_child[rows_per_child][ARRAY_SIZE]\cf8 ;\
\
            \cf5 // Initialize the array elements to zero\
            \cf8 for \cf6 (\cf8 int \cf6 i = \cf7 0\cf8 ; \cf6 i < rows_per_child\cf8 ; \cf6 i++) \{\
                \cf8 for \cf6 (\cf8 int \cf6 j = \cf7 0\cf8 ; \cf6 j < ARRAY_SIZE\cf8 ; \cf6 j++) \{\
                    ans_child[i][j] = \cf7 0\cf8 ;\
                \cf6 \}\
            \}\
            \cf5 // calculate the start and end of the rows assigned to the child\
            \cf8 int \cf6 start_row = i * rows_per_child\cf8 ;\
            int \cf6 end_row = (i == NUM_CHILDREN - \cf7 1\cf6 ) ? ARRAY_SIZE : (i + \cf7 1\cf6 ) * rows_per_child\cf8 ;\
\
            \cf5 // evaluate the child multiplication\
            \cf8 for \cf6 (\cf8 int \cf6 x = start_row\cf8 ; \cf6 x < end_row\cf8 ; \cf6 x++) \{\
                \cf8 for \cf6 (\cf8 int \cf6 j = \cf7 0\cf8 ; \cf6 j < ARRAY_SIZE\cf8 ; \cf6 j++) \{\
                    ans_child[x - start_row][j] = \cf7 0\cf8 ;\
                    for \cf6 (k = \cf7 0\cf8 ; \cf6 k < ARRAY_SIZE\cf8 ; \cf6 k++) \{\
                        ans_child[x - start_row][j] += (idMatrix[x][k] * idxBirthYearMatrix[k][j])\cf8 ;\
                    \cf6 \}\
                \}\
            \}\
\
            \cf5 // Write the result to the pipe\
            \cf6 write(pipe_fds[i][\cf7 1\cf6 ]\cf8 , \cf6 ans_child\cf8 , sizeof\cf6 (ans_child))\cf8 ;\
\
            \cf6 close(pipe_fds[i][\cf7 1\cf6 ])\cf8 ;\
            \cf6 exit(\cf7 0\cf6 )\cf8 ; \cf5 // Exit the child process\
        \cf6 \}\
    \}\
\
    \cf8 for \cf6 (\cf8 int \cf6 i = \cf7 0\cf8 ; \cf6 i < NUM_CHILDREN\cf8 ; \cf6 i++) \{\
        close(pipe_fds[i][\cf7 1\cf6 ])\cf8 ;\
        \cf6 waitpid(pids[i]\cf8 , \cf6 NULL\cf8 , \cf7 0\cf6 )\cf8 ; \cf5 // wait for child process\
        \cf8 int \cf6 temp_result[rows_per_child][ARRAY_SIZE]\cf8 ; \cf5 // To store the child array\
        \cf6 read(pipe_fds[i][\cf7 0\cf6 ]\cf8 , \cf6 temp_result\cf8 , sizeof\cf6 (temp_result))\cf8 ;\
        \cf6 close(pipe_fds[i][\cf7 0\cf6 ])\cf8 ;\
        int \cf6 start_row = i * rows_per_child\cf8 ;\
        int \cf6 end_row = (i == NUM_CHILDREN - \cf7 1\cf6 ) ? ARRAY_SIZE : (i + \cf7 1\cf6 ) * rows_per_child\cf8 ;\
\
        \cf5 // add the partial array to the final array\
        \cf8 for \cf6 (\cf8 int \cf6 x = start_row\cf8 ; \cf6 x < end_row\cf8 ; \cf6 x++) \{\
            \cf8 for \cf6 (\cf8 int \cf6 j = \cf7 0\cf8 ; \cf6 j < ARRAY_SIZE\cf8 ; \cf6 j++) \{\
                multiplicationMatrix[x][j] += temp_result[x - start_row][j]\cf8 ;\
            \cf6 \}\
        \}\
    \}\
\
    gettimeofday(&end_t\cf8 , \cf6 NULL)\cf8 ;  \cf5 // Get the end time\
    \cf8 double \cf6 elapsed_time = (end_t.tv_sec - start_t.tv_sec) + (end_t.tv_usec - start_t.tv_usec) / \cf7 1000000.0\cf8 ;\
    int \cf6 x = NUM_CHILDREN\cf8 ;\
    \cf6 printf(\cf4 "\cf8 \\n\cf4 The time of the multiprocess approach is %f  (%d children) "\cf8 , \cf6 elapsed_time\cf8 ,\cf6 x)\cf8 ;\
\
    \cf5 // Print the final result matrix\
    \cf6 printf(\cf4 "\cf8 \\n\\n\cf4 Result Matrix:\cf8 \\n\cf4 "\cf6 )\cf8 ;\
    for \cf6 (\cf8 int \cf6 i = \cf7 0\cf8 ; \cf6 i < ARRAY_SIZE\cf8 ; \cf6 i++) \{\
        \cf8 for \cf6 (\cf8 int \cf6 j = \cf7 0\cf8 ; \cf6 j < ARRAY_SIZE\cf8 ; \cf6 j++) \{\
            printf(\cf4 "%d "\cf8 , \cf6 multiplicationMatrix[i][j])\cf8 ;\
        \cf6 \}\
        printf(\cf4 "\cf8 \\n\cf4 "\cf6 )\cf8 ;\
    \cf6 \}\
\
    \cf8 return \cf7 0\cf8 ;\
\cf6 \}\
\
\
\
}