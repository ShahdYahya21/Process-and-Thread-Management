{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red173\green169\blue32;\red32\green32\blue32;\red88\green118\blue71;
\red109\green109\blue109;\red191\green100\blue38;\red254\green187\blue91;\red153\green168\blue186;\red166\green165\blue220;
\red86\green132\blue173;}
{\*\expandedcolortbl;;\csgenericrgb\c67843\c66275\c12549;\csgenericrgb\c12549\c12549\c12549;\csgenericrgb\c34510\c46275\c27843;
\csgenericrgb\c42745\c42745\c42745;\csgenericrgb\c74902\c39216\c14902;\csgenericrgb\c99608\c73333\c35686;\csgenericrgb\c60000\c65882\c72941;\csgenericrgb\c65098\c64706\c86275;
\csgenericrgb\c33725\c51765\c67843;}
\paperw11900\paperh16840\margl1440\margr1440\vieww28600\viewh15140\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \cb3 #include \cf4 <stdio.h>\
\cf2 #include \cf4 <sys/time.h>  \cf5 // Include the header for gettimeofday\
\cf6 int \cf7 main\cf8 () \{\
    \cf6 struct \cf9 timeval \cf8 start_t\cf6 , \cf8 end_t\cf6 ;  \cf5 // Use struct timeval for time measurements\
    \cf6 int \cf8 idMatrix[\cf10 100\cf8 ][\cf10 100\cf8 ]\cf6 ;\
    int \cf8 idxBirthYearMatrix[\cf10 100\cf8 ][\cf10 100\cf8 ]\cf6 ;\
    int \cf8 multiplicationMatrix[\cf10 100\cf8 ][\cf10 100\cf8 ]\cf6 ;\
    int \cf8 id = \cf10 1210249\cf6 ;\
    int \cf8 ID[\cf10 10\cf8 ]\cf6 ; \cf5 // 1D array to contain id numbers\
    \cf6 int \cf8 size1 = \cf10 0\cf6 ; \cf5 //size of 1D id array\
\
    // fill the id numbers into 1D array\
    \cf6 while\cf8 (id > \cf10 0\cf8 )\{\
        ID[size1] = id % \cf10 10\cf6 ;\
        \cf8 size1++\cf6 ;\
        \cf8 id /= \cf10 10\cf6 ;\
    \cf8 \}\
\
    \cf5 // reverse the array because it was filled reversed\
    \cf6 for\cf8 (\cf6 int \cf8 i = \cf10 0\cf6 ; \cf8 i < size1 / \cf10 2\cf6 ; \cf8 i++)\{\
        \cf6 int \cf8 temp = ID[i]\cf6 ;\
        \cf8 ID[i] = ID[size1 - \cf10 1 \cf8 - i]\cf6 ;\
        \cf8 ID[size1 - \cf10 1 \cf8 - i] = temp\cf6 ;\
    \cf8 \}\
\
    \cf6 long long \cf8 idMulBirth = \cf10 1210249l \cf8 * \cf10 2003l\cf6 ;\
    int \cf8 idXbirthYear[\cf10 20\cf8 ]\cf6 ;\cf5 // 1D array to contain (id * birth year) numbers\
    \cf6 int \cf8 size2 = \cf10 0\cf6 ; \cf5 // size of 1D id * BirthYear array\
\
    // fill the id multiplied with the birth year into 1D array\
    \cf6 while\cf8 (idMulBirth > \cf10 0\cf8 )\{\
        idXbirthYear[size2] = idMulBirth % \cf10 10\cf6 ;\
        \cf8 idMulBirth /= \cf10 10\cf6 ;\
        \cf8 size2++\cf6 ;\
    \cf8 \}\
    \cf5 // reverse the array because it was filled reversed\
    \cf6 for\cf8 (\cf6 int \cf8 i = \cf10 0\cf6 ; \cf8 i < size2 / \cf10 2\cf6 ; \cf8 i++)\{\
        \cf6 int \cf8 temp = idXbirthYear[i]\cf6 ;\
        \cf8 idXbirthYear[i] = idXbirthYear[size2 - \cf10 1 \cf8 - i]\cf6 ;\
        \cf8 idXbirthYear[size2 - \cf10 1 \cf8 - i] = temp\cf6 ;\
    \cf8 \}\
\
    \cf5 // fill the id matrix and id * birth year matrix\
    \cf6 int \cf8 k = \cf10 0\cf6 ,\cf8 l =\cf10 0\cf6 ;\
    for\cf8 (\cf6 int \cf8 i = \cf10 0\cf6 ; \cf8 i < \cf10 100\cf6 ; \cf8 i++)\{\
        \cf6 for\cf8 (\cf6 int \cf8 j = \cf10 0\cf6 ; \cf8 j < \cf10 100\cf6 ; \cf8 j++)\{\
            \cf6 if\cf8 (k == size1) k = \cf10 0\cf6 ; \cf5 // when the id ends start over\
            \cf6 if\cf8 (l == size2) l = \cf10 0\cf6 ; \cf5 // when the id * birth year number ends start over\
            \cf8 idMatrix[i][j] = ID[k]\cf6 ;\
            \cf8 idxBirthYearMatrix[i][j] = idXbirthYear[l]\cf6 ;\
            \cf8 l++\cf6 ;\
            \cf8 k++\cf6 ;\
        \cf8 \}\
    \}\
    gettimeofday(&start_t\cf6 , \cf8 NULL)\cf6 ;  \cf5 // Get the start time\
\
    // multiplication process\
    \cf6 for \cf8 (\cf6 int \cf8 i = \cf10 0\cf6 ; \cf8 i < \cf10 100\cf6 ; \cf8 i++) \{\
        \cf6 for \cf8 (\cf6 int \cf8 j = \cf10 0\cf6 ; \cf8 j < \cf10 100\cf6 ; \cf8 j++) \{\
            multiplicationMatrix[i][j] = \cf10 0\cf6 ;\
            for\cf8 (\cf6 int \cf8 k = \cf10 0\cf6 ; \cf8 k < \cf10 100\cf6 ; \cf8 k++)\{\
                multiplicationMatrix[i][j] += (idMatrix[i][k] * idxBirthYearMatrix[k][j])\cf6 ;\
\
            \cf8 \}\
        \}\
    \}\
    gettimeofday(&end_t\cf6 , \cf8 NULL)\cf6 ;  \cf5 // Get the end time\
    \cf6 double \cf8 elapsed_time = (end_t.tv_sec - start_t.tv_sec) + (end_t.tv_usec - start_t.tv_usec) / \cf10 1000000.0\cf6 ;\
    \cf8 printf(\cf4 "\cf6 \\n\cf4 The time of the naive approach is %f "\cf6 ,\cf8 elapsed_time)\cf6 ;\
\
    \cf5 // print the result matrix\
    \cf8 printf(\cf4 "\cf6 \\n\\n\cf4 The final matrix : \cf6 \\n\cf4 "\cf8 )\cf6 ;\
    for \cf8 (\cf6 int \cf8 i = \cf10 0\cf6 ; \cf8 i < \cf10 100\cf6 ; \cf8 i++) \{\
        \cf6 for \cf8 (\cf6 int \cf8 j = \cf10 0\cf6 ; \cf8 j < \cf10 100\cf6 ; \cf8 j++) \{\
            printf(\cf4 "%d "\cf6 , \cf8 multiplicationMatrix[i][j])\cf6 ;\
        \cf8 \}\
    \}\
\
\
\
        \cf6 return \cf10 0\cf6 ;\
    \cf8 \}\
\
\
\
\
}