{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red173\green169\blue32;\red32\green32\blue32;\red88\green118\blue71;
\red109\green109\blue109;\red153\green168\blue186;\red86\green132\blue173;\red191\green100\blue38;\red166\green165\blue220;
\red128\green93\blue148;\red171\green173\blue198;\red254\green187\blue91;}
{\*\expandedcolortbl;;\csgenericrgb\c67843\c66275\c12549;\csgenericrgb\c12549\c12549\c12549;\csgenericrgb\c34510\c46275\c27843;
\csgenericrgb\c42745\c42745\c42745;\csgenericrgb\c60000\c65882\c72941;\csgenericrgb\c33725\c51765\c67843;\csgenericrgb\c74902\c39216\c14902;\csgenericrgb\c65098\c64706\c86275;
\csgenericrgb\c50196\c36471\c58039;\csgenericrgb\c67059\c67843\c77647;\csgenericrgb\c99608\c73333\c35686;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \cb3 #include \cf4 <stdio.h>\
\cf2 #include \cf4 <pthread.h>\
\cf2 #include \cf4 <time.h>\
\cf2 #include \cf4 <stdlib.h>\
\cf2 #include \cf4 <sys/time.h>  \cf5 // Include the header for gettimeofday\
\
\cf2 #define \cf6 NumberOfThreads \cf7 16\
\cf8 int \cf6 multiplicationMatrix[\cf7 100\cf6 ][\cf7 100\cf6 ] = \{\cf7 0\cf6 \}\cf8 ; \cf5 // Result matrix\
\cf8 int \cf6 idMatrix[\cf7 100\cf6 ][\cf7 100\cf6 ]\cf8 ;\
int \cf6 idxBirthYearMatrix[\cf7 100\cf6 ][\cf7 100\cf6 ]\cf8 ;\
\
\cf5 // struct task to add to the thread pool\
\cf8 typedef struct \cf9 Task \cf6 \{\
    \cf8 int \cf10 start\cf8 , \cf10 end\cf8 ;\
\cf6 \} \cf11 Task\cf8 ;\
\
\
\cf5 // Thread function to process tasks\
\cf8 void \cf6 *\cf12 startThread\cf6 (\cf8 void \cf6 *task) \{\
    \cf8 struct \cf9 Task \cf6 *myTask = (\cf8 struct \cf9 Task\cf6 *)task\cf8 ;\
\
    \cf5 // Process the task\
    \cf8 for \cf6 (\cf8 int \cf6 x = myTask->\cf10 start\cf8 ; \cf6 x < myTask->\cf10 end\cf8 ; \cf6 x++) \{\
        \cf8 for \cf6 (\cf8 int \cf6 j = \cf7 0\cf8 ; \cf6 j < \cf7 100\cf8 ; \cf6 j++) \{\
            \cf8 for \cf6 (\cf8 int \cf6 k = \cf7 0\cf8 ; \cf6 k < \cf7 100\cf8 ; \cf6 k++) \{\
                multiplicationMatrix[x][j] += (idMatrix[x][k] * idxBirthYearMatrix[k][j])\cf8 ;\
            \cf6 \}\
        \}\
    \}\
\
    pthread_exit(NULL)\cf8 ;\
\
\cf6 \}\
\
\
\cf8 int \cf12 main\cf6 (\cf8 int \cf6 argc\cf8 , char\cf6 * argv[]) \{\
    \cf8 struct \cf9 timeval \cf6 start_t\cf8 , \cf6 end_t\cf8 ;  \cf5 // Use struct timeval for time measurements\
    \cf8 int \cf6 id = \cf7 1210249\cf8 ;\
    int \cf6 ID[\cf7 10\cf6 ]\cf8 ; \cf5 // 1D array to contain id numbers\
    \cf8 int \cf6 size1 = \cf7 0\cf8 ; \cf5 //size of 1D id array\
\
    // fill the id numbers into 1D array\
    \cf8 while\cf6 (id > \cf7 0\cf6 )\{\
        ID[size1] = id % \cf7 10\cf8 ;\
        \cf6 size1++\cf8 ;\
        \cf6 id /= \cf7 10\cf8 ;\
    \cf6 \}\
\
    \cf5 // reverse the array because it was filled reversed\
    \cf8 for\cf6 (\cf8 int \cf6 i = \cf7 0\cf8 ; \cf6 i < size1 / \cf7 2\cf8 ; \cf6 i++)\{\
        \cf8 int \cf6 temp = ID[i]\cf8 ;\
        \cf6 ID[i] = ID[size1 - \cf7 1 \cf6 - i]\cf8 ;\
        \cf6 ID[size1 - \cf7 1 \cf6 - i] = temp\cf8 ;\
    \cf6 \}\
\
    \cf8 long long \cf6 idMulBirth = \cf7 1210249l \cf6 * \cf7 2003l\cf8 ;\
    int \cf6 idXbirthYear[\cf7 20\cf6 ]\cf8 ;\cf5 // 1D array to contain (id * birth year) numbers\
    \cf8 int \cf6 size2 = \cf7 0\cf8 ; \cf5 // size of 1D id * BirthYear array\
\
    // fill the id multiplied with the birth year into 1D array\
    \cf8 while\cf6 (idMulBirth > \cf7 0\cf6 )\{\
        idXbirthYear[size2] = idMulBirth % \cf7 10\cf8 ;\
        \cf6 idMulBirth /= \cf7 10\cf8 ;\
        \cf6 size2++\cf8 ;\
    \cf6 \}\
    \cf5 // reverse the array because it was filled reversed\
    \cf8 for\cf6 (\cf8 int \cf6 i = \cf7 0\cf8 ; \cf6 i < size2 / \cf7 2\cf8 ; \cf6 i++)\{\
        \cf8 int \cf6 temp = idXbirthYear[i]\cf8 ;\
        \cf6 idXbirthYear[i] = idXbirthYear[size2 - \cf7 1 \cf6 - i]\cf8 ;\
        \cf6 idXbirthYear[size2 - \cf7 1 \cf6 - i] = temp\cf8 ;\
    \cf6 \}\
\
    \cf5 // fill the id matrix and id * birth year matrix\
    \cf8 int \cf6 k = \cf7 0\cf8 ,\cf6 l =\cf7 0\cf8 ;\
    for\cf6 (\cf8 int \cf6 i = \cf7 0\cf8 ; \cf6 i < \cf7 100\cf8 ; \cf6 i++)\{\
        \cf8 for\cf6 (\cf8 int \cf6 j = \cf7 0\cf8 ; \cf6 j < \cf7 100\cf8 ; \cf6 j++)\{\
            \cf8 if\cf6 (k == size1) k = \cf7 0\cf8 ; \cf5 // when the id ends start over\
            \cf8 if\cf6 (l == size2) l = \cf7 0\cf8 ; \cf5 // when the id * birth year number ends start over\
            \cf6 idMatrix[i][j] = ID[k]\cf8 ;\
            \cf6 idxBirthYearMatrix[i][j] = idXbirthYear[l]\cf8 ;\
            \cf6 l++\cf8 ;\
            \cf6 k++\cf8 ;\
        \cf6 \}\
    \}\
\
    \cf8 int \cf6 splitIndex = \cf7 100 \cf6 / NumberOfThreads\cf8 ;\
    \cf6 pthread_t th[NumberOfThreads]\cf8 ;\
\
    \cf6 gettimeofday(&start_t\cf8 , \cf6 NULL)\cf8 ;  \cf5 // Get the start time\
\
    \cf8 for \cf6 (\cf8 int \cf6 i = \cf7 0\cf8 ; \cf6 i < NumberOfThreads\cf8 ; \cf6 i++) \{\
        \cf8 int \cf6 start = i * splitIndex\cf8 ;\
        int \cf6 end = (i == NumberOfThreads - \cf7 1\cf6 ) ? \cf7 100 \cf6 : (i + \cf7 1\cf6 ) * splitIndex\cf8 ;\
        struct \cf9 Task \cf6 *t = (\cf8 struct \cf9 Task \cf6 *)malloc(\cf8 sizeof\cf6 (\cf8 struct \cf9 Task\cf6 ))\cf8 ;\
        \cf6 t->\cf10 start \cf6 = start\cf8 ;\
        \cf6 t->\cf10 end \cf6 = end\cf8 ;\
        \cf5 // Create threads to process tasks\
        \cf8 if \cf6 (pthread_create(&th[i]\cf8 , \cf6 NULL\cf8 , \cf6 startThread\cf8 , \cf6 (\cf8 void \cf6 *)t) != \cf7 0\cf6 ) \{\
            printf(\cf4 "Failed to create the thread"\cf6 )\cf8 ;\
        \cf6 \}\
    \}\
\
    \cf5 // Wait for all threads to finish\
    \cf8 for \cf6 (\cf8 int \cf6 i = \cf7 0\cf8 ; \cf6 i < NumberOfThreads\cf8 ; \cf6 i++) \{\
        \cf8 if \cf6 (pthread_join(th[i]\cf8 , \cf6 NULL) != \cf7 0\cf6 ) \{\
            printf(\cf4 "Failed to join the thread"\cf6 )\cf8 ;\
        \cf6 \}\
    \}\
\
    gettimeofday(&end_t\cf8 , \cf6 NULL)\cf8 ;  \cf5 // Get the end time\
\
    // Calculate the elapsed time in seconds\
    \cf8 double \cf6 elapsed_time = (end_t.tv_sec - start_t.tv_sec) + (end_t.tv_usec - start_t.tv_usec) / \cf7 1000000.0\cf8 ;\
    \cf6 printf(\cf4 "\cf8 \\n\cf4 The time of the multithreading approach is %f seconds"\cf8 , \cf6 elapsed_time)\cf8 ;\
\
    \cf5 // print the result matrix\
    \cf6 printf(\cf4 "\cf8 \\n\\n\cf4 The final matrix : \cf8 \\n\cf4 "\cf6 )\cf8 ;\
    for \cf6 (\cf8 int \cf6 i = \cf7 0\cf8 ; \cf6 i < \cf7 100\cf8 ; \cf6 i++) \{\
        \cf8 for \cf6 (\cf8 int \cf6 j = \cf7 0\cf8 ; \cf6 j < \cf7 100\cf8 ; \cf6 j++) \{\
            printf(\cf4 "%d "\cf8 , \cf6 multiplicationMatrix[i][j])\cf8 ;\
        \cf6 \}\
        printf(\cf4 "\cf8 \\n\cf4 "\cf6 )\cf8 ;\
    \cf6 \}\
\
    \cf8 return \cf7 0\cf8 ;\
\cf6 \}\
}